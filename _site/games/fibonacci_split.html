<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
    <meta http-equiv="Content-Style-Type" content="text/css"/>
    <title> Fibonacci Split &mdash; Alexander Wilson</title>
    <link rel="stylesheet" href="/assets/style.css" />
</head>
<body>
    <header>
        <h1>Fibonacci Split</h1>
    </header>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
    });
</script>

<style>
		button {
		border: 1px solid #696969;
		margin-left: .05in;
	}
	.game button {
		font-size: 25px;
		width: 35px;
		height: 35px;
		margin-left:.1in;
		cursor: pointer;
	}

	.game button.active {
		font-weight: bold;
	}

	.game-wrapper {
		width: 100%;
		text-align: center;
		margin: .2in;
	}

	.game-wrapper .caption {
		margin-top: .1in;
	}
</style>

On this page, I describe a game I've dubbed <b>Fibonacci Split</b> inspired by a mathematical observation my collaborators and I came across in our research. I hope you'll play around with it and that it might in turn inspire more mathematical inquiry.

<h3>Fibonacci Numbers</h3>

The Fibonacci numbers are a sequence of numbers beginning with $F_0=0$ and $F_1=1$ generated by the recursive rule that for $i\geq2$, $$F_{n}=F_{n-1}+F_{n-2}.$$

The first few terms of the Fibonacci sequence are $$0, 1, 1, 2, 3, 5, 8, 13, 21, \ldots.$$

This sequence of numbers appears often both in mathematical research and in nature.

<h3>The Game</h3>

While working on a paper, my co-authors and I encountered the identity $$F_{i} + F_{i+4} = 3F_{i+2}\text{ for }i\geq0,$$ and while verifying this identity, we found the process of splitting and re-combining the Fibonacci terms really fun! We can represent each Fibonacci term by a tile indicating its offset from the index $i$ (for example, $F_{i_4}$ corresponds to <button>4</button>). The Fibonacci recurrence allows us two kinds of moves for $n\geq2$:
<ol>
 	<li>splitting (<button>$n$</button>$\rightarrow$<button>$n-2$</button><button>$n-1$</button>), and</li>
 	<li>combining (<button>$n-2$</button><button>$n-1$</button>$\rightarrow$<button>$n$</button>).</li>
 </ol>

 Try applying these moves below (clicking twice on a tile to split and clicking on two tiles to combine) to see if you can verify the identity used in our paper (the end result should look like <button>2</button><button>2</button><button>2</button>).

<div class="game-wrapper">
	<div class="game">0,4</div>
	<div class="caption"><b>Game 1:</b> The original identity with initial state <button>0</button><button>4</button>.</div>
</div>

I wanted to try to turn this little exercise into a game. The goal in our paper was to replace the left-hand side of the identity with a simpler expression, so our goal in this game will be to try to end with as few distinct values in our tiles as possible. Because we want our identities to be valid for all $i\geq0$, we won't allow ourselves to split the tiles <button>0</button> or <button>1</button>.

<div class="game-wrapper">
	<div class="game">0,1,1,1,4</div>
	<div class="caption"><b>Game 2:</b> Try to work this game down to only one distinct value.</div>
</div>

There definitely appear to be initial states that can't be combined into a state of all one value. I couldn't accomplish this feat in the following.
<div class="game-wrapper">
	<div class="game">0,2,5</div>
	<div class="caption"><b>Game 3:</b> Try to work this game down to as few distinct values as you can.</div>
</div>

<h3>Further Questions</h3>

Playing around with this game has raised some interesting questions for me. I'll list some of these questions below, and if you find yourself wondering "what if...?" while playing, I hope you'll <a href="mailto:awilson6@oberlin.edu">tell me about it</a>!

<ul>
	<li>What characterizes initial states that can always be brought to a single distinct value?</li>
	<li>What is a good strategy for reducing to the minimum number of distinct values in the fewest number of steps?</li>
	<div class="game-wrapper">
		<div class="game" id="mutable-game">0,4</div>
		<div class="caption"><b>Game 4:</b> Try playing around with different initial states by typing a comma-separated list in <input type="text" id="mutable-input"/> and pressing enter.</div>
	</div>
	<li>If we allowed ourselves to split values smaller than two (i.e. allowed negative values in tiles), could we reduce to fewer distinct values?</li>
	<div class="game-wrapper">
		<div class="game" id="mutable-neg-game">0,4</div>
		<div class="caption"><b>Game 5:</b> This game will let you split into negative tiles. Set your initial state in <input type="text" id="mutable-neg-input"/>.</div>
	</div>
	<li>In our paper, we also encountered products of two Fibonacci numbers. Could one devise a two-dimensional version of this game to explore these products?</li>
</ul>

<script>
	// Control scheme DRAG or TAP
	var CONTROL_SCHEME = "TAP";

	document.getElementById("mutable-input").addEventListener("keypress", function (e) {
		if (e.key == "Enter") {
			array = e.target.value.split(",");
	        initialize_game(array, document.getElementById("mutable-game"));
	    }
	})

	document.getElementById("mutable-neg-input").addEventListener("keypress", function (e) {
		if (e.key == "Enter") {
			array = e.target.value.split(",");
	        initialize_game(array, document.getElementById("mutable-neg-game"));
	    }
	})

	function initialize_game (array, pieces, allow_negative) {

		if (pieces.id == "mutable-neg-game") {
			allow_negative = true;
		}

		pieces.innerHTML = "";
		for (var i = 0; i < array.length; i++) {
			const button = document.createElement("button");
			button.innerHTML = array[i];
			pieces.appendChild(button);
		}

		function split_button (button) {
			const value = +button.innerHTML;

			if (value > 1 || allow_negative) {
				const split1 = document.createElement("button");
				const split2 = document.createElement("button");
				split1.innerHTML = value - 1;
				split2.innerHTML = value - 2;
				pieces.insertBefore(split2, button);
				pieces.insertBefore(split1, button);
				pieces.removeChild(button);
			}
			else
			{
				console.log("Failed to split", button);
			}
		}

		function combine_buttons (button1, button2) {
			const value1 = +button1.innerHTML;
			const value2 = +button2.innerHTML;

			if (Math.abs(value1 - value2) == 1) {
				const combined = document.createElement("button");
				combined.innerHTML = Math.max(value1, value2) + 1;
				pieces.insertBefore(combined, button1);
				pieces.removeChild(button1);
				pieces.removeChild(button2);
			}
			else
			{
				console.log("Failed to combine", button1, button2);
			}
		}

		var initial_target = null;

		function trigger_interaction (target) {
			if (initial_target != null) {
				if (initial_target == target) {
					split_button(target);
				}
				else
				{
					combine_buttons(initial_target, target);
				}
				initial_target.classList.remove("active");
				initial_target = null;
			}
			else
			{
				target.classList.add("active");
				initial_target = target;
			}
		}

		pieces.onmousedown = function(e) {
			if (CONTROL_SCHEME == "DRAG") {
				if (e.target.tagName == "BUTTON") {
					trigger_interaction(e.target);
				}
			}
		}

		pieces.onmouseup = function (e) {
			if (CONTROL_SCHEME == "DRAG") {
				if (e.target.tagName == "BUTTON") {
					trigger_interaction(e.target);
				}
			}
		}

		pieces.onclick = function (e) {
			if (CONTROL_SCHEME == "TAP") {
				if (e.target.tagName == "BUTTON") {
					trigger_interaction(e.target);
				}
			}
		}

		document.addEventListener("click", function(e){
			if (initial_target != null && e.target.tagName != "BUTTON") {
				initial_target.classList.remove("active");
				initial_target = null;
			}
		}); 
	}

	games = document.getElementsByClassName("game");

	for (var i = 0; i < games.length; i++) {
		array = games[i].innerHTML.split(",");
		initialize_game(array, games[i]);
	}
</script>
</body>
</html>